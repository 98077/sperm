* protobuf
   - http://code.google.com/p/protobuf/
   - http://code.google.com/apis/protocolbuffers/docs/overview.html
   - http://code.google.com/apis/protocolbuffers/docs/proto.html
   - http://code.google.com/apis/protocolbuffers/docs/cpptutorial.html
   - http://code.google.com/apis/protocolbuffers/docs/encoding.html
   - http://code.google.com/apis/protocolbuffers/docs/reference/cpp-generated.html
   - http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.descriptor.html
   - http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.message.html

** language
功能列表 protobuf
是否支持include import 
是否支持名字空间 package 是否支持typedef 否 是否支持常量 否 是否支持枚举 是 是否支持结构 message 是否支持定义异常 否 是否需要字段标识 是 字段是否支持可选 是 是否类型嵌套定义 是 是否支持RPC结构 service 是否支持默认值 是 

类型C类型Java类型bool bool boolean int32 int32_t int int64 int64_t long sint32 int32_t int sint64 int64_t int uint32 int32_t int uint64 int64_t long sfixed32 int32_t int sfixed64 int64_t long fixed32 uint32_t int fixed64 uint64_t long string std::string String bytes std::string ByteStringfloat float float double double double 


   * 对于常量只能够使用简单的类型的常量.
   * 字段标识对于1-15使用1个字节进行存储,16-2047使用2个字节进行存储.所以1-15应该用于表示频繁使用的字段.对于字段表示1-2^29-1,并且19000-19999这个范围保留
   * 对于int32,int64,uint32,uint64采用variable-length encoding来进行编码,这个在后面会有解释.对于这种编码的话越大的数占用的字节数目越多.
   * 对于int32,int64的负数来说占用字节数是非常多的.为了解决这个问题引入sint32,sint64.这两种类型和int32和int64相同,但是在编码上会首先zig-zag,然后再使用variable-length encoding来进行编码.这个在后面也会进行解释.最后采用little-endian来进行存储
   * 对于sfixed,sfixed64,fixed32,fixed64,float,double使用原本的字节大小存储,并且采用little-endian方式来进行存储
   * 对于java的话存储uint32还是使用int来完成,不过最高位不作为符号位.
   * 对于protobuf的import导入机制是这样的
      * 假设x.proto中有import "y.proto"
      * 调用protoc --cpp_out=. x.proto
      * 生成x.pb.h和x.pb.cc
      * x.pb.h中包含y.pb.h,但是外部没有产生y.pb.h和y.pb.cc
      * 所以其实外面还需要自己手动调用proto --cpp_out. y.proto
   * extensions能够为结构体保留某些字段编号标识,方便对第三方库进行扩展.后面会对extensions部分的代码进行分析
   * 提供了选项optimize_for,包括SPEED,CODE_SIZE和LITE_RUNTIME.其中LITE_RUNTIME的意思是使用尽可能少的protobuf功能,比如descriptors和反射等.
   * 提供了自定义选项.可以参考http://code.google.com/apis/protocolbuffers/docs/proto.html#options
   * 对于protoc编译器如果--cpp_out=后面以.zip结尾的话,那么.c和.h文件都会放入zip文件中.


生成代码层面使用下面的x.proto文件

package X;message SUB{        required int32 a=1;}message PACK {        extensions 100 to 199;        optional int32 a_555=1;        required string b_555=2 [default="hello"] ;        repeated bytes c_555=3;        required SUB d_555=4;}extend PACK{        optional int32 bar=126;}
会产生下面两个文件x.pb.h和x.pb.cc.其中x.pb.h产生各个类的声明.这里只是举PACK类为例，同时删除了部分代码只是为了方便说明问题.至于x.pb.cc部分的话放在二进制协议层面进行分析..关于产生接口部分的话，详细内容还可以参看http://code.google.com/apis/protocolbuffers/docs/reference/cpp-generated.html

namespace X {        //基类::google::protobuf::Message        //如果在x.proto中有option optimize_for=LITE_RUNTIME;的话,那么会继承于MessageLite        //但是这样的话讲不会存在Unknown字段，descriptor以及反射机制.        class PACK : public ::google::protobuf::Message {                 public:                PACK();                virtual ~PACK();                PACK(const PACK& from);                  inline PACK& operator=(const PACK& from) {                        CopyFrom(from);                        return *this;                }                                //对于不认识字段使用::google::protobuf::UnknownFieldSet进行包装.                inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {                        return _unknown_fields_;                }                  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {                        return &_unknown_fields_;                }                                //::google::protobuf::Descriptor用于反射.                static const ::google::protobuf::Descriptor* descriptor();                //创建单例                static const PACK& default_instance();                //交换对象                void Swap(PACK* other);                                // implements Message ----------------------------------------------                                PACK* New() const;                void CopyFrom(const ::google::protobuf::Message& from);                void MergeFrom(const ::google::protobuf::Message& from);                void CopyFrom(const PACK& from);                void MergeFrom(const PACK& from);                void Clear(); //清除字段                bool IsInitialized() const; //是否必选字段都进行了初始化                                //::google::protobuf::io::CodedInputStream                int ByteSize() const; //使用protocol串行化大小                bool MergePartialFromCodedStream(                ::google::protobuf::io::CodedInputStream* input);                void SerializeWithCachedSizes(                ::google::protobuf::io::CodedOutputStream* output) const;                ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;                int GetCachedSize() const { return _cached_size_; }                private:                void SharedCtor();                void SharedDtor();                void SetCachedSize(int size) const;                public:                                //得到原信息::google::protobuf::Metadata                ::google::protobuf::Metadata GetMetadata() const;                                // nested types ----------------------------------------------------                                // accessors -------------------------------------------------------                //访问函数..                //基本类型都是用::google::protobuf::进行了封装..                // optional int32 a_555 = 1;                 inline bool has_a_555() const; //has                inline void clear_a_555(); //clear                static const int kA555FieldNumber = 1; //对于每一个字段的话都有FieldNumber.                inline ::google::protobuf::int32 a_555() const; //获取                inline void set_a_555(::google::protobuf::int32 value); //set.                                // required string b_555 = 2 [default = "hello"];                inline bool has_b_555() const;                inline void clear_b_555();                static const int kB555FieldNumber = 2;                inline const ::std::string& b_555() const;                inline void set_b_555(const ::std::string& value);                inline void set_b_555(const char* value);                inline void set_b_555(const char* value, size_t size);                inline ::std::string* mutable_b_555();                                //数组的访问接口,里面有::google::protobuf::RepeatedPtrField来做                // repeated bytes c_555 = 3;                inline int c_555_size() const;                inline void clear_c_555();                static const int kC555FieldNumber = 3;                inline const ::std::string& c_555(int index) const;                inline ::std::string* mutable_c_555(int index);                inline void set_c_555(int index, const ::std::string& value);                inline void set_c_555(int index, const char* value);                inline void set_c_555(int index, const void* value, size_t size);                inline ::std::string* add_c_555();                inline void add_c_555(const ::std::string& value);                inline void add_c_555(const char* value);                inline void add_c_555(const void* value, size_t size);                inline const ::google::protobuf::RepeatedPtrField< ::std::string>& c_555() const;                inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_c_555();                                // required .X.SUB d_555 = 4;                inline bool has_d_555() const;                inline void clear_d_555();                static const int kD555FieldNumber = 4;                inline const ::X::SUB& d_555() const;                inline ::X::SUB* mutable_d_555();                                //对于extension的部分的话使用这个宏来处理,后面会有更多的分析.                GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PACK)                private:                ::google::protobuf::internal::ExtensionSet _extensions_; //extension字段部分                ::google::protobuf::UnknownFieldSet _unknown_fields_; //unknown字段部分                mutable int _cached_size_;                                ::google::protobuf::int32 a_555_;                ::std::string* b_555_;                static const ::std::string _default_b_555_; //这里有定义的基本常量                //在.cc文件中会进行初始化...                                ::google::protobuf::RepeatedPtrField< ::std::string> c_555_;                ::X::SUB* d_555_; //可以看到都是使用指针来进行存储的..                                //使用_has_bits_来判断字段是否进行设置..                //这对于字段较多的结构体可以节省空间..                  //多少个字段(X+32)/32个大小..                ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];                                // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?                inline bool _has_bit(int index) const {                        return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;                }                inline void _set_bit(int index) {                        _has_bits_[index / 32] |= (1u << (index % 32));                }                inline void _clear_bit(int index) {                        _has_bits_[index / 32] &= ~(1u << (index % 32));                }                                void InitAsDefaultInstance();                //单例..                static PACK* default_instance_;        };        // ===================================================================                // 对于extension部分的话除了上面的宏还有::google::protobuf::internal::ExtensionIdentifier        // 和::google::protobuf::internal::PrimitiveTypeTraits        static const int kBarFieldNumber = 126;        extern ::google::protobuf::internal::ExtensionIdentifier< ::X::PACK,        ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >        bar;
问题

   * 对于默认值会在构造函数时填充
   * 嵌套类型产生是这样的，假设在写得时候是


message A{        message B        {        }}
的话，那么会产生A和A_B两个类型，然后再A中typedef A_B B来完成嵌套类型的代码生成

   * 如果使用option optimize_for=LITE_RUNTIME的话，那么不识别的字段会丢弃。默认情况下的话会保存在UnknownSet的结构里面


二进制协议层面图示

   * 对于tag，组成的形式是(fid << 3) | (wire_type) [读写单位uint32]，这个可以参见encoding的文档部分http://code.google.com/apis/protocolbuffers/docs/encoding.html
   * wire_type包括下面几种类型
      * WIRETYPE_VARINT 采用varint128进行编码存储
      * WIRETYPE_FIXED64 采用64位定长存储存储
      * WIRETYPE_LENGTH_DELIMITED 表示存值的方式是len+data，往后面读int32来作为长度
      * WIRETYPE_START_GROUP 表示group的初始，这个废弃了
      * WIRETYPE_END_GROUP 表示group的终结，这个也废弃了
      * WIRETYPE_FIXED32 采用32位定长存储

框架代码框架代码在x.pb.cc里面实现,还是以PACK为例同时删除了部分代码.

namespace X {                void PACK::Clear() {                //首先清除扩展部分...                _extensions_.Clear();                //首先检查是否设置过..如果有部分设置的话那么就会清除每个字段                if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {                        //如果设置的话那么都会设置返回为默认值...                        a_555_ = 0;                        if (_has_bit(1)) {                                if (b_555_ != &_default_b_555_) {                                        b_555_->assign(_default_b_555_);                                }                        }                        if (_has_bit(3)) {                                if (d_555_ != NULL) d_555_->::X::SUB::Clear();                        }                }                //然后对于数组的话统一clear..                c_555_.Clear();                //清除_has_bits_字段                ::memset(_has_bits_, 0, sizeof(_has_bits_));                //清除unknown字段...                mutable_unknown_fields()->Clear();        }                bool PACK::MergePartialFromCodedStream(        //可以看到::google::protobuf::io::就是流式部分..        //::google::protobuf::internal::WireFormatLite        //和::google::protobuf::internal::WireFormat是编码部分..        ::google::protobuf::io::CodedInputStream* input) {                #define DO_(EXPRESSION) if (!(EXPRESSION)) return false                ::google::protobuf::uint32 tag;                //首先读取tag出来,然后使用GetTagFieldNumber来转换成为field number部分...                while ((tag = input->ReadTag()) != 0) {                        switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {                                // optional int32 a_555 = 1;                                case 1: {                                        //判断是否为VARINT编码...                                        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==                                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {                                                //读取原始类型...                                                DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<                                                ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(                                                input, &a_555_)));                                                _set_bit(0); //这个字段读取到了..                                        } else {                                                goto handle_uninterpreted; //否则进行处理..                                        }                                        //这里能够加快流程..                                        //因为这里可能会进行预读入..18=2[field no]<<3+2[这个部分可以参见encoding部分]                                        if (input->ExpectTag(18)) goto parse_b_555;                                        break;                                }                                                                // required string b_555 = 2 [default = "hello"];                                case 2: {                                        //判断是否为LENGTH_DELIMITED的,以长度来进行区分...                                        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==                                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {                                                parse_b_555:                                                //读取字符串类型..                                                DO_(::google::protobuf::internal::WireFormatLite::ReadString(                                                input, this->mutable_b_555()));                                                //会进行验证UTF8..                                                ::google::protobuf::internal::WireFormat::VerifyUTF8String(                                                this->b_555().data(), this->b_555().length(),                                                ::google::protobuf::internal::WireFormat::PARSE);                                        } else {                                                goto handle_uninterpreted;                                        }                                        //26=3<<3+2                                        if (input->ExpectTag(26)) goto parse_c_555;                                        break;                                }                                                                // repeated bytes c_555 = 3;                                //bytes部分不进行UTF8检查.                                case 3: {                                        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==                                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {                                                parse_c_555:                                                DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(                                                input, this->add_c_555()));                                        } else {                                                goto handle_uninterpreted;                                        }                                        //对于repeated字段的话那么会直接进行跳转..                                        if (input->ExpectTag(26)) goto parse_c_555;                                        //34=4<<3+2                                        if (input->ExpectTag(34)) goto parse_d_555;                                        break;                                }                                                                // required .X.SUB d_555 = 4;                                case 4: {                                        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==                                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {                                                parse_d_555:                                                //读取一个Message..                                                DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(                                                input, mutable_d_555()));                                        } else {                                                goto handle_uninterpreted;                                        }                                        if (input->ExpectAtEnd()) return true;                                        break;                                }                                                                default: {                                        handle_uninterpreted:                                        //如果读取到结尾的话..                                        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==                                        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {                                                return true;                                        }                                        //对于extension部分也是parse的..                                        if ((800u <= tag && tag < 1600u)) {                                                DO_(_extensions_.ParseField(tag, input, default_instance_,                                                mutable_unknown_fields()));                                                continue;                                        }                                        //对于不认识的字段的话则会跳过..                                        DO_(::google::protobuf::internal::WireFormat::SkipField(                                        input, tag, mutable_unknown_fields()));                                        break;                                }                        }                }                return true;                #undef DO_        }                //里面也是按照字段来逐个编写..但是注意这里有一个问题        //基本上里面Write分为两种方法,WriteXXX和WriteXXXToArray..是为了效率问题???        void PACK::SerializeWithCachedSizes(        ::google::protobuf::io::CodedOutputStream* output) const {                // optional int32 a_555 = 1;                if (_has_bit(0)) {                        ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->a_555(), output);                }                                // required string b_555 = 2 [default = "hello"];                if (_has_bit(1)) {                        ::google::protobuf::internal::WireFormat::VerifyUTF8String(                        this->b_555().data(), this->b_555().length(),                        ::google::protobuf::internal::WireFormat::SERIALIZE);                        ::google::protobuf::internal::WireFormatLite::WriteString(                        2, this->b_555(), output);                }                                // repeated bytes c_555 = 3;                for (int i = 0; i < this->c_555_size(); i++) {                        ::google::protobuf::internal::WireFormatLite::WriteBytes(                        3, this->c_555(i), output);                }                                // required .X.SUB d_555 = 4;                if (_has_bit(3)) {                        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(                        4, this->d_555(), output);                }                                //extension部分会打包..                // Extension range [100, 200)                _extensions_.SerializeWithCachedSizes(                100, 200, output);                                //会将不认识的字段打包                if (!unknown_fields().empty()) {                        ::google::protobuf::internal::WireFormat::SerializeUnknownFields(                        unknown_fields(), output);                }        }                ::google::protobuf::uint8* PACK::SerializeWithCachedSizesToArray(        ::google::protobuf::uint8* target) const {                // optional int32 a_555 = 1;                if (_has_bit(0)) {                        target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->a_555(), target);                }                                // required string b_555 = 2 [default = "hello"];                if (_has_bit(1)) {                        ::google::protobuf::internal::WireFormat::VerifyUTF8String(                        this->b_555().data(), this->b_555().length(),                        ::google::protobuf::internal::WireFormat::SERIALIZE);                        target =                        ::google::protobuf::internal::WireFormatLite::WriteStringToArray(                        2, this->b_555(), target);                }                                // repeated bytes c_555 = 3;                for (int i = 0; i < this->c_555_size(); i++) {                        target = ::google::protobuf::internal::WireFormatLite::                        WriteBytesToArray(3, this->c_555(i), target);                }                                // required .X.SUB d_555 = 4;                if (_has_bit(3)) {                        target = ::google::protobuf::internal::WireFormatLite::                        WriteMessageNoVirtualToArray(                        4, this->d_555(), target);                }                                // Extension range [100, 200)                target = _extensions_.SerializeWithCachedSizesToArray(                100, 200, target);                                if (!unknown_fields().empty()) {                        target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(                        unknown_fields(), target);                }                return target;        }                //BytesSize能够直接计算出如果打包的话需要多少个字节而实际上不进行任何打包..        int PACK::ByteSize() const {                int total_size = 0;                                if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {                        // optional int32 a_555 = 1;                        if (has_a_555()) {                                total_size += 1 + //对于tag占用一个字节...                                ::google::protobuf::internal::WireFormatLite::Int32Size(                                this->a_555());                        }                                                // required string b_555 = 2 [default = "hello"];                        if (has_b_555()) {                                total_size += 1 +                                ::google::protobuf::internal::WireFormatLite::StringSize(                                this->b_555());                        }                                                // required .X.SUB d_555 = 4;                        if (has_d_555()) {                                total_size += 1 +                                ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(                                this->d_555());                        }                                        }                // repeated bytes c_555 = 3;                total_size += 1 * this->c_555_size();                for (int i = 0; i < this->c_555_size(); i++) {                        total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(                        this->c_555(i));                }                                total_size += _extensions_.ByteSize();                                if (!unknown_fields().empty()) {                        total_size +=                        ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(                        unknown_fields());                }                GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();                _cached_size_ = total_size;                GOOGLE_SAFE_CONCURRENT_WRITES_END();                return total_size;        }                bool PACK::IsInitialized() const {                if ((_has_bits_[0] & 0x0000000a) != 0x0000000a) return false;                                if (has_d_555()) {                        if (!this->d_555().IsInitialized()) return false;                }                                if (!_extensions_.IsInitialized()) return false;  return true;        }        }  // namespace X

Protobuf二进制代码在产生二进制代码中,下面几个类是非常重要的:

   * ::google::protobuf::io::CodedInputStream
   * ::google::protobuf::RepeatedPtrField
   * ::google::protobuf::UnknownFieldSet
   * ::google::protobuf::internal::WireFormatLite
   * ::google::protobuf::internal::WireFormat


io::CodedInputStream在这里有分析http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.io.coded_stream.html.使用的编码方式可以参考http://code.google.com/apis/protocolbuffers/docs/encoding.html,这里简单地介绍一下里面编码的内容

   * 对于varint128都是针对整型正数进行编码.
   * 特点就是对于值越大的整数使用的字节数目越多
   * 但是引来一个问题就是对于负数的话,会溢出成为正数越大.并且通常值都会很大
   * 为了解决这个问题引入了两种类型sint32和sint64.首先采用zig-zag编码转换成为整数[通常对于小的负数能够转换成为小的正数],然后使用varint128进行编码.


RepeatedPtrField内部实现类似于std::vector,内部数组初始长度为4,然后扩容时候翻倍. 但是和std::vector以及IDL[20100825]实现稍微有点不同.这个不同造成set和visit访问效率差别

   * IDL实现通过deque实现,因为我们可能希望产生空洞数组.使用deque是一种非常方便的做法.但是这样造成visit效率不佳[需要一些间接访问]
   * protobuf的RepeatedPtrField实现的话,只相当于从后面连续追加,所以没有使用deque的方法,visit效率较高
   * *但是和std::vector的不同是,protobuf里面所有的类都没有构造函数.所以RepeatedPtrField的resize实现可以仅仅memcpy然后返回void * *
   * 而std::vector进行resize的时候,需要重新构造一次内容,然后析够原有内容
   * 这样造成IDL如果替换成为std::vector的话,set效率不佳.


UnknownFieldSet内部存放std::vector<UnknownField*>,然后每一个UnknownField内部数据是一个union,分为下面几种类型

   * TYPE_VARINT,
   * TYPE_FIXED32,
   * TYPE_FIXED64,
   * TYPE_LENGTH_DELIMITED 属于string这样的数据
   * TYPE_GROUP UnknownFieldSet结构


internal::WireFormatLite关于二进制部分内容的话实际上做了一个分层

   * Wire部分的话进行zigzag转换，并且double,float转换成为uint32和uint64.这样CodeInputStream这段处理的就是uint32和uint64类型
   * Wire部分还进行field no和type合成为tag.这点可以参考http://code.google.com/apis/protocolbuffers/docs/encoding.html.


internal::WireFormat基本上WireFormat和WireFormatLite是基本相同.不同的地方就是对待UnknownField.WireFormatLite中不支持UnknownField,而WireFormat能够串行和反串行化UnknownField.

Extension之前看到了在产生的x.pb.h里面有

::google::protobuf::internal::ExtensionSet _extensions_;......GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PACK)......static const int kBarFieldNumber = 126;extern ::google::protobuf::internal::ExtensionIdentifier< ::X::PACK,::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >bar;
同时在x.pb.cc里面有

::google::protobuf::internal::ExtensionIdentifier< ::X::PACK,::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >bar(kBarFieldNumber, 0);
下面来看看这个部分生成的代码.分为4个部分

   * ::google::protobuf::internal::PrimitiveTypeTraits/RepeatedPrimitiveTypeTraits
   * ::google::protobuf::internal::MessageTypeTraits/RepeatedMessageTypeTraits
   * ::google::protobuf::internal::StringTypeTraits/RepeatedStringTypeTraits
   * ::google::protobuf::internal::ExtensionIdentifier
   * GOOGLE_PROTOBUF_EXTENSION_ACCESSORS
   * ::google::protobuf::internal::ExtensionSet


internal::PrimitiveTypeTraits/RepeatedPrimitiveTypeTraits

template <typename Type>class PrimitiveTypeTraits {        public:        typedef Type ConstType;        static inline ConstType Get(int number, const ExtensionSet& set,        ConstType default_value);        static inline void Set(int number, FieldType field_type,        ConstType value, ExtensionSet* set);};template <typename Type>class RepeatedPrimitiveTypeTraits {        public:        typedef Type ConstType;        static inline Type Get(int number, const ExtensionSet& set, int index);        static inline void Set(int number, int index, Type value, ExtensionSet* set);        static inline void Add(int number, FieldType field_type,        bool is_packed, Type value, ExtensionSet* set);};
这个类型需要萃取出Get,Set,对于数组的话还有Add.但是ExtensionSet中只有SetInt32,SetRepeatedInt32这样的接口,所以这里还有一个宏产生下面这样的代码

template <> inline int32 PrimitiveTypeTraits<int32>::Get(int number,Const ExtensionSet &set,ConstType default_value){        return set.Getint32(number,default_value);}

internal::MessageTypeTraits/RepeatedMessageTypeTraits这个类和上面功能差不多,但是由于ExtensionSet中提供统一的GetMessage和GetRepeatedMessage这样的接口,所以能够在Get和Set还有Add内部写代码

template <typename Type>class MessageTypeTraits {        public:        typedef const Type& ConstType;        typedef Type* MutableType;                static inline ConstType Get(int number, const ExtensionSet& set,        ConstType default_value) {                return static_cast<const Type&>(                set.GetMessage(number, default_value));        }        static inline MutableType Mutable(int number, FieldType field_type,        ExtensionSet* set) {                return static_cast<Type*>(                set->MutableMessage(number, field_type, Type::default_instance(), NULL));        }};template <typename Type>class RepeatedMessageTypeTraits {        public:        typedef const Type& ConstType;        typedef Type* MutableType;                static inline ConstType Get(int number, const ExtensionSet& set, int index) {                return static_cast<const Type&>(set.GetRepeatedMessage(number, index));        }        static inline MutableType Mutable(int number, int index, ExtensionSet* set) {                return static_cast<Type*>(set->MutableRepeatedMessage(number, index));        }        static inline MutableType Add(int number, FieldType field_type,        ExtensionSet* set) {                return static_cast<Type*>(                set->AddMessage(number, field_type, Type::default_instance(), NULL));        }};

internal::StringTypeTraits/RepeatedStringTypeTraits这个类和上面::google::protobuf::internal::MessageTypeTraits/RepeatedMessageTypeTraits差不多,也不需要进行特话.

::google::protobuf::internal::ExtensionIdentifier这个类萃取出了number即字段的标签号还有default_value即默认值..

template <typename ExtendeeType, typename TypeTraitsType,FieldType field_type, bool is_packed>class ExtensionIdentifier {        public:        typedef TypeTraitsType TypeTraits;        typedef ExtendeeType Extendee;                ExtensionIdentifier(int number, typename TypeTraits::ConstType default_value)        : number_(number), default_value_(default_value) {}        inline int number() const { return number_; }        typename TypeTraits::ConstType default_value() const {                return default_value_;        }                private:        const int number_;        typename TypeTraits::ConstType default_value_;};

GOOGLE_PROTOBUF_EXTENSION_ACCESSORS这个宏产生了一系列的访问方法

   * HasExtension
   * ClearExtension
   * ExtensionSize
   * GetExtension
   * MutableExtension
   * SetExtension
   * AddExtension

每一个方法传入的都是::google::protobuf::internal::ExtensionIdentifier这个对象

internal::ExtensionSet这个类比较复杂但是数据结构比较简单,就是一个大union

struct Extension {        union {                int32        int32_value;                int64        int64_value;                uint32       uint32_value;                uint64       uint64_value;                float        float_value;                double       double_value;                bool         bool_value;                int          enum_value;                string*      string_value;                MessageLite* message_value;                                RepeatedField   <int32      >* repeated_int32_value;                RepeatedField   <int64      >* repeated_int64_value;                RepeatedField   <uint32     >* repeated_uint32_value;                RepeatedField   <uint64     >* repeated_uint64_value;                RepeatedField   <float      >* repeated_float_value;                RepeatedField   <double     >* repeated_double_value;                RepeatedField   <bool       >* repeated_bool_value;                RepeatedField   <int        >* repeated_enum_value;                RepeatedPtrField<string     >* repeated_string_value;                RepeatedPtrField<MessageLite>* repeated_message_value;        };        map<int, Extension> extensions_;
这样加入在上面pack.SetExtension(bar,5)的话,实际上是调用pack._extensions_.Setint32(bar.id_number(),5),最终就是extensions_[bar.id_number()]=Extension(5).

描述符[Descriptor]关于描述符的接口可以参考http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.descriptor.html,关于产生描述符部分的代码如下.ps: *这个部分其实没有仔细看,因为内部的读取格式是二进制的,但是猜想是这样完成的"

void protobuf_AddDesc_x_2eproto() {        //不要重复进行初始化..        static bool already_here = false;        if (already_here) return;        already_here = true;        GOOGLE_PROTOBUF_VERIFY_VERSION;                //下面二进制的内容就是作为描述符内容        //每一个文件作为一个描述符加入pool中        ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(        "\n\007x.proto\022\001X\"\020\n\003SUB\022\t\n\001a\030\001 \002(\005\"X\n\004PACK\022\r"        "\n\005a_555\030\001 \001(\005\022\024\n\005b_555\030\002 \002(\t:\005hello\022\r\n\005c"        "_555\030\003 \003(\014\022\025\n\005d_555\030\004 \002(\0132\006.X.SUB*\005\010d\020\310\001"        ":\024\n\003bar\022\007.X.PACK\030~ \001(\005", 142);        //后面还需要注册很多内容..        ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(        "x.proto", &protobuf_RegisterTypes);        SUB::default_instance_ = new SUB();        PACK::default_instance_ = new PACK();        ::google::protobuf::internal::ExtensionSet::RegisterExtension(        &::X::PACK::default_instance(),        126, 5, false, false);        SUB::default_instance_->InitAsDefaultInstance();        PACK::default_instance_->InitAsDefaultInstance();        ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_x_2eproto);}//这里使用一个静态对象来进行初始化..// Force AddDescriptors() to be called at static initialization time.struct StaticDescriptorInitializer_x_2eproto {        StaticDescriptorInitializer_x_2eproto() {                protobuf_AddDesc_x_2eproto();        }} static_descriptor_initializer_x_2eproto_;
实际上从后面能够看得到,protobuf将所有的描述符都放在一个pool中,然后根据文件名从pool中获取描述符

反射[Reflection]首先看看在产生的代码中是如何来为反射做准备的.....

void protobuf_AssignDesc_x_2eproto() {        //首先确保已经添加了描述符.        protobuf_AddDesc_x_2eproto();        //从pool中根据文件名获取描述符.        const ::google::protobuf::FileDescriptor* file =        ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(        "x.proto");        GOOGLE_CHECK(file != NULL);        //得到第一个message.,看来这个是按照顺序来进行编排的..:)        SUB_descriptor_ = file->message_type(0);        //然后将各个字段的偏移值存起来..        static const int SUB_offsets_[1] = {                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SUB, a_),        };        //然后结合所有的信息注册产生一个反射类,信息包括        //1.descriptor 描述符        //2.单例        //3.各个字段的偏移值        //4.has_bit的偏移值        //5.unknown_field的偏移值        //6.extension的偏移        //7.描述符pool        //8.信息产生工厂        //9.object size..        SUB_reflection_ =        new ::google::protobuf::internal::GeneratedMessageReflection(        SUB_descriptor_,        SUB::default_instance_,        SUB_offsets_,        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SUB, _has_bits_[0]),        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SUB, _unknown_fields_),        -1,        ::google::protobuf::DescriptorPool::generated_pool(),        ::google::protobuf::MessageFactory::generated_factory(),        sizeof(SUB));                //然后得到第二个结构PACK..        PACK_descriptor_ = file->message_type(1);        static const int PACK_offsets_[4] = {                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PACK, a_555_),                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PACK, b_555_),                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PACK, c_555_),                GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PACK, d_555_),        };        PACK_reflection_ =        new ::google::protobuf::internal::GeneratedMessageReflection(        PACK_descriptor_,        PACK::default_instance_,        PACK_offsets_,        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PACK, _has_bits_[0]),        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PACK, _unknown_fields_),        GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PACK, _extensions_),        ::google::protobuf::DescriptorPool::generated_pool(),        ::google::protobuf::MessageFactory::generated_factory(),        sizeof(PACK));}
很明显这里面使用了GeneratedMessageReflection这个类，这个类继承于Reflection.反射的实现都在这里完成...这里就不详细说明了,可以参看文件google/protobuf/generated_message_reflection.h[.cc].原理是这样的

   * 对于每一个FieldDescriptor有一个方法index(),表示这个字段是第几个字段
   * 对于每一个FieldDescriptor有一个方法is_extension(),表示这个是否扩展字段
   * 对于扩展字段能够通过FindKnownExtensionByNumber访问
   * 对于普通的字段能够通过第几个字段计算出偏移，然后计算出内存地址.

文档可以参考这里http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.message.html

参考文章列表

